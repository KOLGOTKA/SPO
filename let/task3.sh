#!/bin/bash

#read input data
read -p "Please write your phrase: " -r
read -p "Please write your shift: " -r shft
declare -a phrase

#split the string into characters
while IFS="" read -r -n 1 c; do
#  опции read:
#  -a <ARRAY>	считывает по слову в массив <ARRAY> вместо нормальных переменных.
#  -d <DELIM>	распознает <DELIM> вместо символа <newline>, для обозначения конца строки.
#  -e	для интерактивной оболочки: использует Bash-интерфейс readline для того что бы читать данные
#  -i <STRING>	:V4: preloads the input buffer with text from <STRING>, only works when Readline (-e) is used
#  -n <NCHARS>	число, считывает <NCHARS> символов ввода и выходит.
#  -N <NCHARS>	:V4:число, считывает <NCHARS> cимволов ввода, игнорируя всякие символы окончания строки и выходит.
#  -p <PROMPT>	строка приглашения <PROMPT>. Без оконечного перевода строки, Обычно в ней выводят подсказку, перед тем как команда read будет считывать данные.
#  -r	сырой ввод - отключает интерпретацию , backslash escapes  и символов продолжения строки в считываемых данных
#  -s	секретный ввод, не выводит в терминал введенные данные. (для вводов паролей)
#  -t таймаут. ожидает данных <TIMEOUT> секунд и потом выходит (с exit code 1). :V4:Дробный  <TIMEOUT> в секунадах  ("5.33") разрешен. Значение 0 -  0 немедленно возвращает и показывает если данные ждут -immediately returns and indicates if data is waiting in the exit code. Timeout означает код возврата больше 128. Если таймаут наступает раньше чем чем все данные будут получены - будет возвращена лишь полученная часть данных.
#  -u <FD>	используется файловый дескриптор <FD> , взамен stdin (0)
  phrase+=("$c")
done <<<$REPLY
#REPLY - переменная по-умолчанию, куда записывается ввод пользователя,
#выполненный с помощью команды read если явно не задана другая переменная.
result=()

#loop scrambler

#Спецификаторы преобразования типа printf (это символ, каторый определяет, как интерпретировать соотвествуюший агумент)
#Они бывают следующих типов:
#%b — Распечатайте аргумент, расширяя escape — последовательности обратной косой черты.
#%q — Вывести аргумент в кавычках, многократно используемый в качестве ввода.
#%d, %i- Печать аргумента как десятичное целое.
#%u — Вывести аргумент в виде десятичного целого числа без знака.
#%o — Вывести аргумент в виде восьмеричного целого без знака.
#%x, %X — Вывести аргумент в виде шестнадцатеричного целого числа без знака. %x печатает строчные буквы и %X печатает прописные.
#%e, %E — Вывести аргумент в виде числа с плавающей запятой в экспоненциальной записи. %e печатает строчные буквы и %E печатает прописные.
#%a, %A — Вывести аргумент в виде числа с плавающей запятой в шестнадцатеричной дробной записи. %a печатает строчные буквы и %A печатает прописные.
#%g, %G — Вывести аргумент в виде числа с плавающей точкой в обычной или экспоненциальной записи, в зависимости от того, что больше подходит для данного значения и точности. %g печатает строчные буквы и %G печатает прописные.
#%c — Распечатать аргумент в виде одного символа.
#%f — Распечатайте аргумент как число с плавающей точкой.
#%s — Распечатать аргумент в виде строки.
#%% — Напечатайте буквальный символ %.

for ((i = 0; i < ${#phrase[@]}; i++)); do
  code=$(printf "%d" "'${phrase[$i]}'")
  #  Параметр для printf после обязательного указания спецификатора преобразования указывается в двойных кавычках (""),
  #  однако заключение в эти кавычки, сохраняет буквальное значение всех символов внутри, кроме $,`,\ и !. В свою очередь
  #  заключение в одиночные кавычки ('') сохраняет буквальное значение каждого символа внутри кавычек. И так как мы не хотим,
  #  чтобы сохранялось специальное значение символа $, нам необходими заключить его в ''

  #case with number
  if (((($code >= 48)) && (($code <= 57)))); then
    result[$i]=$((9 - ${phrase[$i]}))
  #case with letter
  elif (((($code >= 65)) && (($code <= 90)))); then
    #add shift
    res=$(($shft + $code - 64))
    #check overflow
    final_code=$(($res % 26 + 64))
    #check registry
    if (($i % 2 != 0)); then
      final_code=$(($final_code + 32))
    fi
    #write letter
    result[$i]=$(printf "\\$(printf '%03o' "$final_code")")
    	#"printf '%03o'" означает, что мы преобразовываем
    	# тип переменной 3-значное восьмиричное число
    	#printf \\$(...) печатает символ, представленный восьмеричным значением
  else
    result[$i]=${phrase[$i]}
  fi
done

#printing
for ((i = $((${#result[@]} - 1)); i >= 0; i--)); do
  if (($(printf "%d" "'${phrase[$i]}'") == 32)); then
    echo -n " "
  else
    echo -n ${result[$i]}
  fi
done
exit 0
